clear; clc; close all;

K = [0 0 0];   % Cria as constantes Kp, Ki e Kd iniciais

dK = [1 1 1];  % Estabelece as variações diferenciais iniciais de Kp, Ki e Kd

ksi = 1/100;   % Estabelece o incremento/decremento das variações diferenciais de Kp, Ki e Kd

delta = 0.001  % Estabelece a tolerãncia ao erro

% Para usar a média no cálculo do erro, escolha modo = 1
% Para usar desvio padrão no cálculo do erro, escolha modo = 2
modo = 1;

Erro_best = SimulaProcesso(K , 0, modo); % Calcula o erro ao percorrer a trajetória para dado conjunto K
                                         % O parâmetro 0 é para que não seja plotada a simulação
k = 0;% Contador de iterações

 while sum(dK) > delta                   % Enquanto a soma de dK para cada K for menor que a tolerância do erro
    
     k = k+1;                            % Atualiza o número da iteração
      
     for i = 1:length(K)                 % Para Kp, Ki e Kd
         
         K(i) = K(i) + dK(i);            % Atualiza Kp, Ki e Kd somando dK
         
         Erro = SimulaProcesso(K , 0, modo); % Calcula o erro ao percorrer a trajetória para dado conjunto K
         
         if Erro < Erro_best                 % Se o erro atual for menor que o menor erro registrado
             
             Erro_best = Erro;               % Então o erro atual é o novo menor erro
             
             dK(i) = dK(i) * (1+ksi);        % Dk aumeta para que o erro reduza ainda mais rápido
             
         else                                % Senão
              
             K(i) = K(i) - 2*dK(i);          % Atualiza Kp, Ki e Kd subtraindo 2*dK
             
             Erro = SimulaProcesso(K , 0, modo); %  Calcula o erro ao percorrer a trajetória para dado conjunto K
             
             if Erro < Erro_best             % Se o erro atual for menor que o menor erro registrado
                 
                 Erro_best = Erro;           % Então o erro atual é o novo menor erro
                 
                 dK(i) = dK(i) * (i + ksi);  % Dk aumeta para que o erro reduza ainda mais rápido
                 
             else                            % Senão                   
                 
                 K(i) = K(i) + dK(i);        % Atualiza Kp, Ki e Kd somando dK (retornando aos valores do início da iteração
                 
                 dK(i) = dK(i) * (1 - ksi);  % dK diminui para que o algoritmo não oscile sem encontrar solução
                 
             end   
             
         end                                                            
         
         
     end
     fprintf('Rodada = %i: Melhor Erro = %.4f, soma(dK) = %.6f\n', k , Erro_best , sum(dK)) % Printa o número da iteração, 
                                                                                            % o menor erro encontrado
                                                                                            % e a soma das variações diferenciais iniciais de Kp, Ki e Kd
 end

fprintf('Parametros: P = %.4f, I = %.4f, D = %.4f', K(1) , K(2) , K(3))     % Printa os parâmetros Kp, Ki e Kd otimizados 
                                                                            % Pelo Twiddle após a condição de tolerância do erro ser atendida

SimulaProcesso(K, 1, modo);                                               % Plota o robô se movendo a um ponto de raio 2 e ângulo 45° (1° quadrante)
